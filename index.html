<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&family=Varela+Round&family=Nunito:wght@400;600;700;800;900&family=Baloo+2:wght@400;500;600;700;800&family=Righteous&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Varela Round', 'Baloo 2', 'Quicksand', sans-serif;
            text-align: center;
            background: linear-gradient(135deg, #ffeef8 0%, #f0e6ff 30%, #e6f3ff 60%, #f8f0ff 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 12% 8%, rgba(255, 182, 193, 0.5) 0%, transparent 12%),
                radial-gradient(circle at 88% 15%, rgba(221, 160, 221, 0.4) 0%, transparent 16%),
                radial-gradient(circle at 22% 75%, rgba(175, 238, 238, 0.5) 0%, transparent 14%),
                radial-gradient(circle at 78% 5%, rgba(255, 240, 245, 0.6) 0%, transparent 10%),
                radial-gradient(circle at 95% 65%, rgba(230, 230, 250, 0.4) 0%, transparent 18%),
                radial-gradient(circle at 8% 92%, rgba(255, 218, 185, 0.5) 0%, transparent 13%),
                radial-gradient(circle at 65% 88%, rgba(255, 228, 225, 0.4) 0%, transparent 15%),
                radial-gradient(circle at 35% 22%, rgba(240, 248, 255, 0.5) 0%, transparent 11%),
                radial-gradient(circle at 82% 45%, rgba(245, 245, 220, 0.4) 0%, transparent 17%),
                radial-gradient(circle at 28% 58%, rgba(230, 255, 250, 0.5) 0%, transparent 14%),
                radial-gradient(circle at 98% 3%, rgba(255, 240, 245, 0.4) 0%, transparent 9%),
                radial-gradient(circle at 3% 48%, rgba(248, 248, 255, 0.5) 0%, transparent 15%),
                radial-gradient(circle at 52% 12%, rgba(255, 192, 203, 0.4) 0%, transparent 13%),
                radial-gradient(circle at 18% 35%, rgba(230, 230, 250, 0.5) 0%, transparent 16%),
                radial-gradient(circle at 72% 68%, rgba(255, 250, 240, 0.4) 0%, transparent 12%),
                radial-gradient(circle at 45% 95%, rgba(240, 255, 240, 0.5) 0%, transparent 14%),
                radial-gradient(circle at 92% 82%, rgba(255, 228, 196, 0.4) 0%, transparent 11%),
                radial-gradient(circle at 6% 65%, rgba(250, 240, 230, 0.5) 0%, transparent 13%),
                radial-gradient(circle at 58% 38%, rgba(255, 250, 250, 0.4) 0%, transparent 15%),
                radial-gradient(circle at 85% 28%, rgba(245, 255, 250, 0.5) 0%, transparent 12%);
            pointer-events: none;
            z-index: -1;
            animation: float-bubbles 25s ease-in-out infinite;
        }
        
        .background-layer-2 {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 42% 18%, rgba(255, 235, 238, 0.3) 0%, transparent 8%),
                radial-gradient(circle at 68% 78%, rgba(238, 221, 238, 0.3) 0%, transparent 10%),
                radial-gradient(circle at 15% 55%, rgba(240, 248, 255, 0.3) 0%, transparent 9%),
                radial-gradient(circle at 78% 35%, rgba(255, 245, 238, 0.3) 0%, transparent 11%),
                radial-gradient(circle at 25% 85%, rgba(248, 255, 255, 0.3) 0%, transparent 7%),
                radial-gradient(circle at 95% 15%, rgba(255, 250, 205, 0.3) 0%, transparent 12%),
                radial-gradient(circle at 5% 25%, rgba(230, 255, 230, 0.3) 0%, transparent 8%),
                radial-gradient(circle at 55% 5%, rgba(255, 240, 245, 0.3) 0%, transparent 10%),
                radial-gradient(circle at 32% 72%, rgba(245, 245, 255, 0.3) 0%, transparent 9%),
                radial-gradient(circle at 88% 88%, rgba(255, 255, 240, 0.3) 0%, transparent 11%);
            pointer-events: none;
            z-index: -1;
            animation: float-bubbles-secondary 30s ease-in-out infinite reverse;
        }
        
        @keyframes float-bubbles {
            0%, 100% { transform: translateY(0px) scale(1) rotate(0deg); }
            25% { transform: translateY(-15px) scale(1.03) rotate(2deg); }
            50% { transform: translateY(-8px) scale(0.97) rotate(-1deg); }
            75% { transform: translateY(-20px) scale(1.02) rotate(1deg); }
        }
        
        @keyframes float-bubbles-secondary {
            0%, 100% { transform: translateY(0px) scale(1) rotate(0deg); }
            33% { transform: translateY(-12px) scale(1.01) rotate(-1deg); }
            66% { transform: translateY(-6px) scale(0.99) rotate(1deg); }
        }
        
        .container {
            max-width: min(500px, 95vw);
            margin: 0 auto;
        }
        
        h1 {
            color: #9b59b6;
            font-size: clamp(32px, 8vw, 48px);
            margin: 20px 0;
            text-shadow: 0 2px 4px rgba(155, 89, 182, 0.3);
            font-weight: 600;
            background: linear-gradient(45deg, #9b59b6, #e8b4e3, #dda0dd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
        }
        
        h1::after {
            content: '✨';
            position: absolute;
            top: -10px;
            right: -30px;
            font-size: 24px;
            animation: sparkle-float 3s ease-in-out infinite;
        }
        
        @keyframes sparkle-float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(180deg); }
        }
        
        .header-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .score-container {
            display: flex;
            gap: 15px;
        }
        
        .score-box {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(248, 240, 255, 0.9) 100%);
            color: #8e44ad;
            padding: 15px 25px;
            border-radius: 20px;
            font-weight: 600;
            box-shadow: 0 8px 25px rgba(155, 89, 182, 0.2);
            border: 2px solid rgba(221, 160, 221, 0.4);
            backdrop-filter: blur(15px);
        }
        
        .game-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.7) 0%, rgba(248, 240, 255, 0.8) 100%);
            border-radius: 30px;
            width: min(500px, 95vw);
            height: min(500px, 95vw);
            position: relative;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 20px 40px rgba(155, 89, 182, 0.2), 0 0 0 1px rgba(221, 160, 221, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(20px);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .grid-cell {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(20px, 4vw, 35px);
            font-weight: bold;
            color: #776e65;
            border: 2px solid rgba(221, 160, 221, 0.2);
            box-shadow: inset 0 2px 6px rgba(255, 255, 255, 0.5);
        }
        
        .tile {
            background-color: #eee4da;
            border-radius: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(20px, 4vw, 35px);
            font-weight: 700;
            color: #8e44ad;
            position: absolute;
            width: calc((100% - 60px) / 4);
            height: calc((100% - 60px) / 4);
            transition: all 0.15s cubic-bezier(0.23, 1, 0.32, 1);
            z-index: 10;
            box-shadow: 0 6px 15px rgba(155, 89, 182, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.6);
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }
        
        .tile.tile-new {
            animation: tile-appear 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        @keyframes tile-appear {
            0% {
                transform: scale(0) rotate(180deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) rotate(90deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        @keyframes tile-merge {
            0% {
                transform: scale(1);
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            }
            25% {
                transform: scale(1.05);
                box-shadow: 0 12px 30px rgba(221, 160, 221, 0.4);
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 15px 35px rgba(221, 160, 221, 0.5), 0 0 15px rgba(255, 255, 255, 0.6);
                filter: brightness(1.2) saturate(1.3);
            }
            75% {
                transform: scale(1.05);
                box-shadow: 0 12px 30px rgba(221, 160, 221, 0.3);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
                filter: brightness(1) saturate(1);
            }
        }
        
        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        @keyframes score-popup {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 0;
            }
            20% {
                transform: translateY(-10px) scale(1.2);
                opacity: 1;
            }
            80% {
                transform: translateY(-30px) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(0.8);
                opacity: 0;
            }
        }
        
        @keyframes sparkle {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1) rotate(180deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }
        
        .score-popup {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            background: linear-gradient(45deg, #ffb6c1, #dda0dd, #87ceeb, #f0e68c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 10px rgba(255, 182, 193, 0.8);
            pointer-events: none;
            z-index: 100;
            animation: score-popup 1.5s ease-out forwards;
            filter: drop-shadow(0 2px 8px rgba(221, 160, 221, 0.6));
        }
        
        .score-popup::before {
            content: '✨';
            position: absolute;
            left: -25px;
            top: -5px;
            font-size: 16px;
            animation: sparkle-rotate 1s ease-in-out infinite;
        }
        
        .score-popup::after {
            content: '✨';
            position: absolute;
            right: -25px;
            top: -5px;
            font-size: 16px;
            animation: sparkle-rotate 1s ease-in-out infinite reverse;
        }
        
        @keyframes sparkle-rotate {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
        }
        
        .merge-star {
            position: absolute;
            pointer-events: none;
            z-index: 99;
            width: 20px;
            height: 20px;
            animation: star-burst 1s ease-out forwards;
        }
        
        .merge-star::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: var(--star-color, linear-gradient(45deg, #ff69b4, #dda0dd, #87ceeb, #ffd700));
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            filter: drop-shadow(0 2px 6px rgba(255, 105, 180, 0.6)) drop-shadow(0 0 8px rgba(221, 160, 221, 0.4));
        }
        
        @keyframes star-burst {
            0% {
                transform: scale(0) translateX(0) translateY(0);
                opacity: 1;
            }
            15% {
                transform: scale(var(--scale, 1)) translateX(calc(var(--random-x, 0px) * 0.3)) translateY(calc(var(--random-y, 0px) * 0.3));
                opacity: 1;
            }
            100% {
                transform: scale(calc(var(--scale, 1) * 0.3)) translateX(var(--random-x, 0px)) translateY(var(--random-y, 0px));
                opacity: 0;
            }
        }
        
        
        .merge-glow {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, transparent 70%);
            pointer-events: none;
            z-index: 5;
            animation: glow-pulse 0.5s ease-out forwards;
        }
        
        @keyframes glow-pulse {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(2);
                opacity: 1;
            }
            100% {
                transform: scale(0);
                opacity: 0;
            }
        }
        
        @keyframes tile-slide {
            0% {
                transform: translateX(var(--start-x)) translateY(var(--start-y));
            }
            100% {
                transform: translateX(0) translateY(0);
            }
        }
        
        .tile.tile-sliding {
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
        }
        
        .tile.tile-merged {
            animation: tile-merge 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        /* ゆめかわパステルカラーパターン - 統一された紫系文字色 */
        .tile-2 { background: linear-gradient(135deg, #ffe4e8 0%, #ffd1dc 100%); color: #8e44ad; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-4 { background: linear-gradient(135deg, #ffe8d6 0%, #ffd4b3 100%); color: #8e44ad; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-8 { background: linear-gradient(135deg, #fff2cc 0%, #ffe6b3 100%); color: #8e44ad; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-16 { background: linear-gradient(135deg, #e8f5e8 0%, #d1f2d1 100%); color: #8e44ad; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-32 { background: linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%); color: #8e44ad; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-64 { background: linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%); color: #8e44ad; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-128 { background: linear-gradient(135deg, #e8eaf6 0%, #c5cae9 100%); color: #8e44ad; font-size: clamp(18px, 3.5vw, 30px); text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-256 { background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%); color: #8e44ad; font-size: clamp(18px, 3.5vw, 30px); text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-512 { background: linear-gradient(135deg, #fce4ec 0%, #f8bbd9 100%); color: #8e44ad; font-size: clamp(18px, 3.5vw, 30px); text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-1024 { background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); color: #8e44ad; font-size: clamp(16px, 3vw, 25px); text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .tile-2048 { background: linear-gradient(135deg, #f1f8e9 0%, #dcedc1 100%); color: #8e44ad; font-size: clamp(16px, 3vw, 25px); text-shadow: 0 1px 2px rgba(255,255,255,0.8); animation: pastel-glow 3s ease-in-out infinite; box-shadow: 0 0 25px rgba(155, 89, 182, 0.4); }
        
        /* 高い数字用の特別パターン */
        .tile-4096 { background: linear-gradient(135deg, #fce4ec 0%, #f8bbd9 50%, #e1bee7 100%); color: #8e44ad; font-size: clamp(14px, 2.5vw, 22px); text-shadow: 0 1px 2px rgba(255,255,255,0.8); animation: pastel-glow 2s ease-in-out infinite; box-shadow: 0 0 30px rgba(155, 89, 182, 0.5); }
        .tile-8192 { background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 50%, #ce93d8 100%); color: #8e44ad; font-size: clamp(14px, 2.5vw, 22px); text-shadow: 0 1px 2px rgba(255,255,255,0.8); animation: pastel-glow 1.5s ease-in-out infinite; box-shadow: 0 0 35px rgba(155, 89, 182, 0.6); }
        
        @keyframes pastel-glow {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(155, 89, 182, 0.4);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 35px rgba(155, 89, 182, 0.7);
                transform: scale(1.02);
            }
        }
        
        .instructions {
            margin-top: 20px;
            color: #8e44ad;
            font-size: clamp(14px, 3vw, 18px);
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.3);
            padding: 15px 20px;
            border-radius: 20px;
            border: 2px solid rgba(221, 160, 221, 0.3);
            backdrop-filter: blur(10px);
            display: inline-block;
        }
        
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            
            .header-container {
                flex-direction: column;
                gap: 15px;
                margin-bottom: 15px;
            }
            
            .score-container {
                gap: 10px;
            }
            
            .score-box {
                padding: 10px 15px;
                font-size: 14px;
            }
            
            button {
                padding: 10px 20px;
                font-size: 14px;
            }
            
            .instructions {
                margin-top: 15px;
                line-height: 1.4;
            }
        }
        
        @media (max-width: 480px) {
            .game-container {
                padding: 10px;
            }
            
            .grid-container {
                gap: 10px;
            }
            
            .tile {
                width: calc((100% - 40px) / 4);
                height: calc((100% - 40px) / 4);
            }
        }
        
        button {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(248, 240, 255, 0.9) 100%);
            border: none;
            border-radius: 20px;
            color: #8e44ad;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            margin: 0;
            box-shadow: 0 8px 20px rgba(155, 89, 182, 0.2);
            transition: all 0.3s ease;
            font-weight: 600;
            border: 2px solid rgba(221, 160, 221, 0.4);
            backdrop-filter: blur(15px);
            white-space: nowrap;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="background-layer-2"></div>
    <div class="container">
        <h1>2048</h1>
        
        <div class="header-container">
            <div class="score-container">
                <div class="score-box">
                    <div>スコア</div>
                    <div id="score">0</div>
                </div>
                <div class="score-box">
                    <div>ベスト</div>
                    <div id="best">0</div>
                </div>
            </div>
            <button onclick="newGame()">新しいゲーム</button>
        </div>
        
        <div class="game-container">
            <div class="grid-container" id="game-grid">
                <!-- 4x4 grid cells will be generated here -->
            </div>
        </div>
        
        <div class="instructions">
<strong>🎮 操作方法</strong><br>
            矢印キー・WASDキー・スワイプ でタイルを移動<br>
            同じ数字のタイルを合体させて高得点を目指そう！
        </div>
    </div>

    <script>
        class Game2048 {
            constructor() {
                this.grid = [];
                this.score = 0;
                this.bestScore = localStorage.getItem('best2048') || 0;
                this.size = 4;
                this.previousGrid = [];
                this.mergedPositions = [];
                this.isProcessing = false; // Prevent concurrent moves
                this.init();
            }
            
            init() {
                this.createGrid();
                this.updateBestScore();
                this.newTilePosition = null; // Initialize new tile tracking
                this.isProcessing = false;
                this.addRandomTile();
                this.addRandomTile();
                this.updateDisplay();
                this.setupEventListeners();
            }
            
            createGrid() {
                this.grid = [];
                for (let i = 0; i < this.size; i++) {
                    this.grid[i] = [];
                    for (let j = 0; j < this.size; j++) {
                        this.grid[i][j] = 0;
                    }
                }
                
                const gameGrid = document.getElementById('game-grid');
                gameGrid.innerHTML = '';
                
                for (let i = 0; i < this.size * this.size; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.id = `cell-${i}`;
                    gameGrid.appendChild(cell);
                }
            }
            
            addRandomTile() {
                const emptyCells = [];
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] === 0) {
                            emptyCells.push({row: i, col: j});
                        }
                    }
                }
                
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const newValue = Math.random() < 0.9 ? 2 : 4;
                    this.grid[randomCell.row][randomCell.col] = newValue;
                    this.newTilePosition = {row: randomCell.row, col: randomCell.col, value: newValue};
                }
            }
            
            updateDisplay() {
                const gameGrid = document.getElementById('game-grid');
                
                // Create background grid if it doesn't exist
                if (!gameGrid.querySelector('.grid-cell')) {
                    for (let i = 0; i < this.size * this.size; i++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        gameGrid.appendChild(cell);
                    }
                }
                
                // Clear all existing tiles to prevent conflicts
                const existingTiles = gameGrid.querySelectorAll('.tile:not(.tile-sliding)');
                existingTiles.forEach(tile => tile.remove());
                
                // Create tiles for current grid state
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] !== 0) {
                            // Calculate position
                            const cellSize = (100 - (3 * 3)) / 4;
                            const left = j * (cellSize + 3);
                            const top = i * (cellSize + 3);
                            
                            // Create new tile
                            const tile = document.createElement('div');
                            tile.className = `tile tile-${this.grid[i][j]}`;
                            
                            // Check if this is the newly generated tile
                            if (this.newTilePosition && 
                                this.newTilePosition.row === i && 
                                this.newTilePosition.col === j && 
                                this.newTilePosition.value === this.grid[i][j]) {
                                tile.classList.add('tile-new');
                                // Clear the new tile position to prevent repeated animation
                                this.newTilePosition = null;
                            }
                            
                            tile.textContent = this.grid[i][j];
                            tile.style.left = `${left}%`;
                            tile.style.top = `${top}%`;
                            gameGrid.appendChild(tile);
                        }
                    }
                }
                
                document.getElementById('score').textContent = this.score;
                document.getElementById('best').textContent = this.bestScore;
            }
            
            animateMove(direction, onAnimationComplete) {
                // Only animate if there are actual movements recorded
                if (!this.moveHistory || this.moveHistory.length === 0) {
                    if (onAnimationComplete) onAnimationComplete();
                    return;
                }
                
                const gameGrid = document.getElementById('game-grid');
                const existingTiles = gameGrid.querySelectorAll('.tile');
                
                // Create a set of positions that moved (from positions)
                const movedFromPositions = new Set();
                this.moveHistory.forEach(moveInfo => {
                    movedFromPositions.add(`${moveInfo.fromRow}-${moveInfo.fromCol}`);
                });
                
                // Only remove tiles that actually moved
                existingTiles.forEach(tile => {
                    const tileLeft = parseFloat(tile.style.left);
                    const tileTop = parseFloat(tile.style.top);
                    const cellSize = (100 - (3 * 3)) / 4;
                    
                    // Calculate which grid position this tile is at
                    const col = Math.round(tileLeft / (cellSize + 3));
                    const row = Math.round(tileTop / (cellSize + 3));
                    const posKey = `${row}-${col}`;
                    
                    // Only remove if this tile moved
                    if (movedFromPositions.has(posKey)) {
                        tile.remove();
                    }
                });
                
                // Create and animate only the tiles that actually moved
                this.moveHistory.forEach(moveInfo => {
                    const tile = document.createElement('div');
                    tile.className = `tile tile-${moveInfo.value} tile-sliding`;
                    tile.textContent = moveInfo.value;
                    
                    // Calculate positions
                    const cellSize = (100 - (3 * 3)) / 4;
                    const oldLeft = moveInfo.fromCol * (cellSize + 3);
                    const oldTop = moveInfo.fromRow * (cellSize + 3);
                    const newLeft = moveInfo.toCol * (cellSize + 3);
                    const newTop = moveInfo.toRow * (cellSize + 3);
                    
                    // Set initial position
                    tile.style.left = `${oldLeft}%`;
                    tile.style.top = `${oldTop}%`;
                    
                    gameGrid.appendChild(tile);
                    
                    // Calculate animation duration based on distance
                    const distance = Math.sqrt(Math.pow(newLeft - oldLeft, 2) + Math.pow(newTop - oldTop, 2));
                    const baseDuration = 150;
                    const animationDuration = Math.max(baseDuration, distance * 1.5);
                    
                    // Apply custom transition duration
                    tile.style.transition = `all ${animationDuration}ms cubic-bezier(0.23, 1, 0.32, 1)`;
                    
                    // Animate to new position
                    setTimeout(() => {
                        tile.style.left = `${newLeft}%`;
                        tile.style.top = `${newTop}%`;
                    }, 20);
                });
                
                // Update display after animation completes and call callback
                setTimeout(() => {
                    this.updateDisplay();
                    if (onAnimationComplete) onAnimationComplete();
                }, 200);
            }
            
            showMergeEffects() {
                const gameGrid = document.getElementById('game-grid');
                
                this.mergedPositions.forEach(pos => {
                    // Add merge animation to the tile
                    const tiles = gameGrid.querySelectorAll('.tile');
                    tiles.forEach(tile => {
                        const cellSize = (100 - (3 * 3)) / 4;
                        const expectedLeft = pos.col * (cellSize + 3);
                        const expectedTop = pos.row * (cellSize + 3);
                        
                        const tileLeft = parseFloat(tile.style.left);
                        const tileTop = parseFloat(tile.style.top);
                        
                        if (Math.abs(tileLeft - expectedLeft) < 1 && 
                            Math.abs(tileTop - expectedTop) < 1 && 
                            parseInt(tile.textContent) === pos.value) {
                            tile.classList.add('tile-merged');
                            
                            // Remove animation class after animation completes
                            setTimeout(() => {
                                tile.classList.remove('tile-merged');
                            }, 500);
                        }
                    });
                    
                    // Show score popup
                    this.showScorePopup(pos.row, pos.col, pos.value);
                    
                    // Show sparkle effects
                    this.showSparkles(pos.row, pos.col);
                    
                    // Show glow effect
                    this.showGlowEffect(pos.row, pos.col);
                });
            }
            
            showScorePopup(row, col, score) {
                const gameGrid = document.getElementById('game-grid');
                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.textContent = `+${score}`;
                
                const cellSize = (100 - (3 * 3)) / 4;
                const left = col * (cellSize + 3) + cellSize / 2;
                const top = row * (cellSize + 3) + cellSize / 2;
                
                popup.style.left = `${left}%`;
                popup.style.top = `${top}%`;
                
                gameGrid.appendChild(popup);
                
                setTimeout(() => {
                    if (popup.parentNode) {
                        popup.parentNode.removeChild(popup);
                    }
                }, 1000);
            }
            
            showSparkles(row, col) {
                const gameGrid = document.getElementById('game-grid');
                const starCount = 16; // More stars for fuller effect
                
                // Define pastel colors for stars
                const starColors = [
                    'linear-gradient(45deg, #ff69b4, #ff91a4)',
                    'linear-gradient(45deg, #dda0dd, #e6b3e6)',
                    'linear-gradient(45deg, #87ceeb, #a4d4f0)',
                    'linear-gradient(45deg, #ffd700, #ffe066)',
                    'linear-gradient(45deg, #ff8c94, #ffa8a8)',
                    'linear-gradient(45deg, #c7ceea, #d9dcf2)',
                    'linear-gradient(45deg, #ffd3a5, #fddd9b)',
                    'linear-gradient(45deg, #a8e6cf, #b8f0d6)'
                ];
                
                for (let i = 0; i < starCount; i++) {
                    const star = document.createElement('div');
                    star.className = 'merge-star';
                    
                    const cellSize = (100 - (3 * 3)) / 4;
                    const centerLeft = col * (cellSize + 3) + cellSize / 2;
                    const centerTop = row * (cellSize + 3) + cellSize / 2;
                    
                    // Create concentric circles with more spread, starting further from center
                    const ring = Math.floor(i / 4); // 4 stars per ring
                    const angleInRing = (i % 4) * 90 + Math.random() * 30 - 15; // 90 degrees apart with small randomness
                    const angle = angleInRing * Math.PI / 180;
                    
                    // Each ring has increasing radius, starting further out to avoid tile text
                    const baseRadius = 50 + ring * 25; // Start at 50px, increase by 25px per ring
                    const randomRadius = baseRadius + Math.random() * 15 - 7; // Add small randomness
                    const randomX = Math.cos(angle) * randomRadius;
                    const randomY = Math.sin(angle) * randomRadius;
                    
                    // Set random star color
                    const colorIndex = Math.floor(Math.random() * starColors.length);
                    star.style.setProperty('--star-color', starColors[colorIndex]);
                    
                    // Center the star properly on the tile center
                    star.style.left = `calc(${centerLeft}% - 10px)`;
                    star.style.top = `calc(${centerTop}% - 10px)`;
                    star.style.setProperty('--random-x', `${randomX}px`);
                    star.style.setProperty('--random-y', `${randomY}px`);
                    star.style.animationDelay = `${i * 30}ms`;
                    
                    gameGrid.appendChild(star);
                    
                    setTimeout(() => {
                        if (star.parentNode) {
                            star.parentNode.removeChild(star);
                        }
                    }, 1200 + i * 30);
                }
            }
            
            showGlowEffect(row, col) {
                const gameGrid = document.getElementById('game-grid');
                const glow = document.createElement('div');
                glow.className = 'merge-glow';
                
                const cellSize = (100 - (3 * 3)) / 4;
                const left = col * (cellSize + 3);
                const top = row * (cellSize + 3);
                
                glow.style.left = `${left}%`;
                glow.style.top = `${top}%`;
                glow.style.width = `${cellSize}%`;
                glow.style.height = `${cellSize}%`;
                
                gameGrid.appendChild(glow);
                
                setTimeout(() => {
                    if (glow.parentNode) {
                        glow.parentNode.removeChild(glow);
                    }
                }, 500);
            }
            
            updateBestScore() {
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem('best2048', this.bestScore);
                }
            }
            
            setupEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    const keyMappings = {
                        'ArrowUp': 'up',
                        'ArrowDown': 'down',
                        'ArrowLeft': 'left',
                        'ArrowRight': 'right',
                        'KeyW': 'up',
                        'KeyS': 'down',
                        'KeyA': 'left',
                        'KeyD': 'right',
                        'w': 'up',
                        's': 'down',
                        'a': 'left',
                        'd': 'right'
                    };
                    
                    if (keyMappings[e.key] || keyMappings[e.code]) {
                        e.preventDefault();
                        const direction = keyMappings[e.key] || keyMappings[e.code];
                        this.handleMove(direction);
                    }
                });
                
                // Touch/Swipe controls
                const gameContainer = document.querySelector('.game-container');
                let touchStartX = 0;
                let touchStartY = 0;
                let touchEndX = 0;
                let touchEndY = 0;
                const minSwipeDistance = 30; // Minimum distance for a swipe
                
                gameContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }, { passive: false });
                
                gameContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });
                
                gameContainer.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    touchEndX = touch.clientX;
                    touchEndY = touch.clientY;
                    
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;
                    const absDeltaX = Math.abs(deltaX);
                    const absDeltaY = Math.abs(deltaY);
                    
                    // Check if swipe is long enough
                    if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) {
                        return;
                    }
                    
                    // Determine swipe direction
                    let direction;
                    if (absDeltaX > absDeltaY) {
                        // Horizontal swipe
                        direction = deltaX > 0 ? 'right' : 'left';
                    } else {
                        // Vertical swipe
                        direction = deltaY > 0 ? 'down' : 'up';
                    }
                    
                    this.handleMove(direction);
                }, { passive: false });
                
                // Mouse drag support for desktop (optional)
                let mouseStartX = 0;
                let mouseStartY = 0;
                let isDragging = false;
                
                gameContainer.addEventListener('mousedown', (e) => {
                    mouseStartX = e.clientX;
                    mouseStartY = e.clientY;
                    isDragging = true;
                });
                
                gameContainer.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                });
                
                gameContainer.addEventListener('mouseup', (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    
                    const deltaX = e.clientX - mouseStartX;
                    const deltaY = e.clientY - mouseStartY;
                    const absDeltaX = Math.abs(deltaX);
                    const absDeltaY = Math.abs(deltaY);
                    
                    // Check if drag is long enough
                    if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) {
                        return;
                    }
                    
                    // Determine drag direction
                    let direction;
                    if (absDeltaX > absDeltaY) {
                        // Horizontal drag
                        direction = deltaX > 0 ? 'right' : 'left';
                    } else {
                        // Vertical drag
                        direction = deltaY > 0 ? 'down' : 'up';
                    }
                    
                    this.handleMove(direction);
                });
                
                // Prevent context menu on long press
                gameContainer.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            
            handleMove(direction) {
                // Prevent concurrent moves
                if (this.isProcessing) {
                    return;
                }
                
                // Check if movement is possible in this direction
                const canMove = this.canMoveInDirection(direction);
                
                if (!canMove) {
                    return; // No movement possible
                }
                
                this.isProcessing = true;
                this.previousGrid = JSON.parse(JSON.stringify(this.grid));
                this.moveHistory = []; // Track all tile movements
                this.mergedPositions = [];
                
                // Execute movement
                let moved = false;
                switch(direction) {
                    case 'left':
                        moved = this.moveLeft();
                        break;
                    case 'right':
                        moved = this.moveRight();
                        break;
                    case 'up':
                        moved = this.moveUp();
                        break;
                    case 'down':
                        moved = this.moveDown();
                        break;
                }
                
                if (moved) {
                    // Logic-based tile generation: determine position immediately after move
                    const emptyPositions = this.getEmptyPositions();
                    const newTilePosition = this.selectRandomPosition(emptyPositions);
                    
                    // Generate new tile immediately (interrupt-safe)
                    this.generateTileAtPosition(newTilePosition);
                    
                    // Show merge effects
                    setTimeout(() => {
                        this.showMergeEffects();
                    }, 200);
                    
                    // Start animation with callback
                    this.animateMove(direction, () => {
                        // Post-animation processing
                        this.updateBestScore();
                        this.isProcessing = false;
                        
                        if (this.isGameOver()) {
                            setTimeout(() => {
                                alert('ゲームオーバー！');
                            }, 100);
                        }
                    });
                } else {
                    this.updateDisplay();
                    this.isProcessing = false;
                }
            }
            
            getEmptyPositions() {
                const emptyPositions = [];
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] === 0) {
                            emptyPositions.push({row: i, col: j});
                        }
                    }
                }
                return emptyPositions;
            }
            
            selectRandomPosition(emptyPositions) {
                if (emptyPositions.length === 0) {
                    return null;
                }
                const randomIndex = Math.floor(Math.random() * emptyPositions.length);
                return emptyPositions[randomIndex];
            }
            
            generateTileAtPosition(position) {
                if (!position) {
                    return;
                }
                
                const newValue = Math.random() < 0.9 ? 2 : 4;
                this.grid[position.row][position.col] = newValue;
                this.newTilePosition = {
                    row: position.row, 
                    col: position.col, 
                    value: newValue
                };
            }
            
            canMoveInDirection(direction) {
                switch(direction) {
                    case 'up':
                        return this.canMoveUpSimple();
                    case 'down':
                        return this.canMoveDownSimple();
                    case 'left':
                        return this.canMoveLeftSimple();
                    case 'right':
                        return this.canMoveRightSimple();
                    default:
                        return false;
                }
            }
            
            canMoveUpSimple() {
                for (let i = 1; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] !== 0) {
                            if (this.grid[i-1][j] === 0) {
                                return true;
                            }
                            if (this.grid[i-1][j] === this.grid[i][j]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            canMoveDownSimple() {
                for (let i = 0; i < this.size - 1; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] !== 0) {
                            if (this.grid[i+1][j] === 0) {
                                return true;
                            }
                            if (this.grid[i+1][j] === this.grid[i][j]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            canMoveLeftSimple() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 1; j < this.size; j++) {
                        if (this.grid[i][j] !== 0) {
                            if (this.grid[i][j-1] === 0) {
                                return true;
                            }
                            if (this.grid[i][j-1] === this.grid[i][j]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            canMoveRightSimple() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size - 1; j++) {
                        if (this.grid[i][j] !== 0) {
                            if (this.grid[i][j+1] === 0) {
                                return true;
                            }
                            if (this.grid[i][j+1] === this.grid[i][j]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            moveLeft() {
                // Check if ANY tile can actually move left
                let canMove = false;
                
                for (let i = 0; i < this.size; i++) {
                    for (let j = 1; j < this.size; j++) { // Start from column 1 (not leftmost)
                        if (this.grid[i][j] !== 0) { // There's a tile here
                            // Check if there's an empty space to the left or a mergeable tile
                            if (this.grid[i][j-1] === 0) {
                                canMove = true;
                                break;
                            }
                            // Check for mergeable tile (same value) to the left
                            if (this.grid[i][j-1] === this.grid[i][j]) {
                                canMove = true;
                                break;
                            }
                        }
                    }
                    if (canMove) break;
                }
                
                if (!canMove) {
                    return false; // No movement possible
                }
                
                // Store original grid to compare later
                const originalGrid = JSON.parse(JSON.stringify(this.grid));
                
                let moved = false;
                
                for (let i = 0; i < this.size; i++) {
                    // Process each row individually with detailed tracking
                    const originalRow = [...this.grid[i]];
                    const nonZeroTiles = [];
                    
                    // Extract non-zero tiles with their original positions
                    for (let j = 0; j < this.size; j++) {
                        if (originalRow[j] !== 0) {
                            nonZeroTiles.push({
                                value: originalRow[j],
                                originalCol: j,
                                currentCol: j
                            });
                        }
                    }
                    
                    // Clear the row
                    for (let j = 0; j < this.size; j++) {
                        this.grid[i][j] = 0;
                    }
                    
                    // Process merges and movements
                    let targetCol = 0;
                    let skipNext = false;
                    
                    for (let tileIndex = 0; tileIndex < nonZeroTiles.length; tileIndex++) {
                        if (skipNext) {
                            skipNext = false;
                            continue;
                        }
                        
                        const currentTile = nonZeroTiles[tileIndex];
                        const nextTile = nonZeroTiles[tileIndex + 1];
                        
                        if (nextTile && currentTile.value === nextTile.value) {
                            // Merge tiles
                            const mergedValue = currentTile.value * 2;
                            this.grid[i][targetCol] = mergedValue;
                            this.score += mergedValue;
                            
                            // Record movements for both tiles involved in merge
                            if (currentTile.originalCol !== targetCol) {
                                this.moveHistory.push({
                                    fromRow: i,
                                    fromCol: currentTile.originalCol,
                                    toRow: i,
                                    toCol: targetCol,
                                    value: currentTile.value,
                                    type: 'merge'
                                });
                                moved = true;
                            }
                            
                            if (nextTile.originalCol !== targetCol) {
                                this.moveHistory.push({
                                    fromRow: i,
                                    fromCol: nextTile.originalCol,
                                    toRow: i,
                                    toCol: targetCol,
                                    value: nextTile.value,
                                    type: 'merge'
                                });
                                moved = true;
                            }
                            
                            // Record merge effect
                            this.mergedPositions.push({
                                row: i,
                                col: targetCol,
                                value: mergedValue
                            });
                            
                            skipNext = true;
                        } else {
                            // Just move the tile
                            this.grid[i][targetCol] = currentTile.value;
                            
                            // Record movement only if position changed
                            if (currentTile.originalCol !== targetCol) {
                                this.moveHistory.push({
                                    fromRow: i,
                                    fromCol: currentTile.originalCol,
                                    toRow: i,
                                    toCol: targetCol,
                                    value: currentTile.value,
                                    type: 'move'
                                });
                                moved = true;
                            }
                        }
                        
                        targetCol++;
                    }
                }
                
                // Check if the grid actually changed
                const gridChanged = !this.gridsEqual(originalGrid, this.grid);
                return gridChanged;
            }
            
            gridsEqual(grid1, grid2) {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (grid1[i][j] !== grid2[i][j]) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            moveRight() {
                // Store original grid to compare later
                const originalGrid = JSON.parse(JSON.stringify(this.grid));
                
                let moved = false;
                
                for (let i = 0; i < this.size; i++) {
                    // Process each row individually with detailed tracking
                    const originalRow = [...this.grid[i]];
                    const nonZeroTiles = [];
                    
                    // Extract non-zero tiles with their original positions
                    for (let j = 0; j < this.size; j++) {
                        if (originalRow[j] !== 0) {
                            nonZeroTiles.push({
                                value: originalRow[j],
                                originalCol: j,
                                currentCol: j
                            });
                        }
                    }
                    
                    // Clear the row
                    for (let j = 0; j < this.size; j++) {
                        this.grid[i][j] = 0;
                    }
                    
                    // Process merges and movements from right to left
                    let targetCol = this.size - 1;
                    let skipNext = false;
                    
                    for (let tileIndex = nonZeroTiles.length - 1; tileIndex >= 0; tileIndex--) {
                        if (skipNext) {
                            skipNext = false;
                            continue;
                        }
                        
                        const currentTile = nonZeroTiles[tileIndex];
                        const nextTile = nonZeroTiles[tileIndex - 1];
                        
                        if (nextTile && currentTile.value === nextTile.value) {
                            // Merge tiles
                            const mergedValue = currentTile.value * 2;
                            this.grid[i][targetCol] = mergedValue;
                            this.score += mergedValue;
                            
                            // Record movements for both tiles involved in merge
                            if (currentTile.originalCol !== targetCol) {
                                this.moveHistory.push({
                                    fromRow: i,
                                    fromCol: currentTile.originalCol,
                                    toRow: i,
                                    toCol: targetCol,
                                    value: currentTile.value,
                                    type: 'merge'
                                });
                                moved = true;
                            }
                            
                            if (nextTile.originalCol !== targetCol) {
                                this.moveHistory.push({
                                    fromRow: i,
                                    fromCol: nextTile.originalCol,
                                    toRow: i,
                                    toCol: targetCol,
                                    value: nextTile.value,
                                    type: 'merge'
                                });
                                moved = true;
                            }
                            
                            // Record merge effect
                            this.mergedPositions.push({
                                row: i,
                                col: targetCol,
                                value: mergedValue
                            });
                            
                            skipNext = true;
                        } else {
                            // Just move the tile
                            this.grid[i][targetCol] = currentTile.value;
                            
                            // Record movement only if position changed
                            if (currentTile.originalCol !== targetCol) {
                                this.moveHistory.push({
                                    fromRow: i,
                                    fromCol: currentTile.originalCol,
                                    toRow: i,
                                    toCol: targetCol,
                                    value: currentTile.value,
                                    type: 'move'
                                });
                                moved = true;
                            }
                        }
                        
                        targetCol--;
                    }
                }
                
                // Check if the grid actually changed
                const gridChanged = !this.gridsEqual(originalGrid, this.grid);
                return gridChanged;
            }
            
            moveUp() {
                // Store original grid to compare later
                const originalGrid = JSON.parse(JSON.stringify(this.grid));
                
                let moved = false;
                
                for (let j = 0; j < this.size; j++) {
                    // Process each column individually with detailed tracking
                    const originalColumn = [];
                    const nonZeroTiles = [];
                    
                    // Extract non-zero tiles with their original positions
                    for (let i = 0; i < this.size; i++) {
                        originalColumn.push(this.grid[i][j]);
                        if (this.grid[i][j] !== 0) {
                            nonZeroTiles.push({
                                value: this.grid[i][j],
                                originalRow: i,
                                currentRow: i
                            });
                        }
                    }
                    
                    // Clear the column
                    for (let i = 0; i < this.size; i++) {
                        this.grid[i][j] = 0;
                    }
                    
                    // Process merges and movements
                    let targetRow = 0;
                    let skipNext = false;
                    
                    for (let tileIndex = 0; tileIndex < nonZeroTiles.length; tileIndex++) {
                        if (skipNext) {
                            skipNext = false;
                            continue;
                        }
                        
                        const currentTile = nonZeroTiles[tileIndex];
                        const nextTile = nonZeroTiles[tileIndex + 1];
                        
                        if (nextTile && currentTile.value === nextTile.value) {
                            // Merge tiles
                            const mergedValue = currentTile.value * 2;
                            this.grid[targetRow][j] = mergedValue;
                            this.score += mergedValue;
                            
                            // Record movements for both tiles involved in merge
                            if (currentTile.originalRow !== targetRow) {
                                this.moveHistory.push({
                                    fromRow: currentTile.originalRow,
                                    fromCol: j,
                                    toRow: targetRow,
                                    toCol: j,
                                    value: currentTile.value,
                                    type: 'merge'
                                });
                                moved = true;
                            }
                            
                            if (nextTile.originalRow !== targetRow) {
                                this.moveHistory.push({
                                    fromRow: nextTile.originalRow,
                                    fromCol: j,
                                    toRow: targetRow,
                                    toCol: j,
                                    value: nextTile.value,
                                    type: 'merge'
                                });
                                moved = true;
                            }
                            
                            // Record merge effect
                            this.mergedPositions.push({
                                row: targetRow,
                                col: j,
                                value: mergedValue
                            });
                            
                            skipNext = true;
                        } else {
                            // Just move the tile
                            this.grid[targetRow][j] = currentTile.value;
                            
                            // Record movement only if position changed
                            if (currentTile.originalRow !== targetRow) {
                                this.moveHistory.push({
                                    fromRow: currentTile.originalRow,
                                    fromCol: j,
                                    toRow: targetRow,
                                    toCol: j,
                                    value: currentTile.value,
                                    type: 'move'
                                });
                                moved = true;
                            }
                        }
                        
                        targetRow++;
                    }
                }
                
                // Check if the grid actually changed
                const gridChanged = !this.gridsEqual(originalGrid, this.grid);
                return gridChanged;
            }
            
            moveDown() {
                // Store original grid to compare later
                const originalGrid = JSON.parse(JSON.stringify(this.grid));
                
                let moved = false;
                
                for (let j = 0; j < this.size; j++) {
                    // Process each column individually with detailed tracking
                    const originalColumn = [];
                    const nonZeroTiles = [];
                    
                    // Extract non-zero tiles with their original positions
                    for (let i = 0; i < this.size; i++) {
                        originalColumn.push(this.grid[i][j]);
                        if (this.grid[i][j] !== 0) {
                            nonZeroTiles.push({
                                value: this.grid[i][j],
                                originalRow: i,
                                currentRow: i
                            });
                        }
                    }
                    
                    // Clear the column
                    for (let i = 0; i < this.size; i++) {
                        this.grid[i][j] = 0;
                    }
                    
                    // Process merges and movements from bottom to top
                    let targetRow = this.size - 1;
                    let skipNext = false;
                    
                    for (let tileIndex = nonZeroTiles.length - 1; tileIndex >= 0; tileIndex--) {
                        if (skipNext) {
                            skipNext = false;
                            continue;
                        }
                        
                        const currentTile = nonZeroTiles[tileIndex];
                        const nextTile = nonZeroTiles[tileIndex - 1];
                        
                        if (nextTile && currentTile.value === nextTile.value) {
                            // Merge tiles
                            const mergedValue = currentTile.value * 2;
                            this.grid[targetRow][j] = mergedValue;
                            this.score += mergedValue;
                            
                            // Record movements for both tiles involved in merge
                            if (currentTile.originalRow !== targetRow) {
                                this.moveHistory.push({
                                    fromRow: currentTile.originalRow,
                                    fromCol: j,
                                    toRow: targetRow,
                                    toCol: j,
                                    value: currentTile.value,
                                    type: 'merge'
                                });
                                moved = true;
                            }
                            
                            if (nextTile.originalRow !== targetRow) {
                                this.moveHistory.push({
                                    fromRow: nextTile.originalRow,
                                    fromCol: j,
                                    toRow: targetRow,
                                    toCol: j,
                                    value: nextTile.value,
                                    type: 'merge'
                                });
                                moved = true;
                            }
                            
                            // Record merge effect
                            this.mergedPositions.push({
                                row: targetRow,
                                col: j,
                                value: mergedValue
                            });
                            
                            skipNext = true;
                        } else {
                            // Just move the tile
                            this.grid[targetRow][j] = currentTile.value;
                            
                            // Record movement only if position changed
                            if (currentTile.originalRow !== targetRow) {
                                this.moveHistory.push({
                                    fromRow: currentTile.originalRow,
                                    fromCol: j,
                                    toRow: targetRow,
                                    toCol: j,
                                    value: currentTile.value,
                                    type: 'move'
                                });
                                moved = true;
                            }
                        }
                        
                        targetRow--;
                    }
                }
                
                // Check if the grid actually changed
                const gridChanged = !this.gridsEqual(originalGrid, this.grid);
                return gridChanged;
            }
            
            isGameOver() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] === 0) {
                            return false;
                        }
                        if (j < this.size - 1 && this.grid[i][j] === this.grid[i][j + 1]) {
                            return false;
                        }
                        if (i < this.size - 1 && this.grid[i][j] === this.grid[i + 1][j]) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            restart() {
                this.score = 0;
                this.newTilePosition = null; // Clear new tile tracking
                this.isProcessing = false;
                this.init();
            }
        }
        
        let game;
        
        function newGame() {
            game = new Game2048();
        }
        
        window.onload = function() {
            game = new Game2048();
        };
    </script>
</body>
</html>